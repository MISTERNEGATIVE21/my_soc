/* 
Explanation:
This module performs arithmetic and logical operations based on the control signals provided.

ALUOp: A 2-bit control signal generated by the ControlUnit that indicates the type of operation.

2'b00: Load/Store instructions (ADD operation).
2'b01: Branch instructions (Subtract or Set Less Than operations).
2'b10: R-type instructions (ADD, SUB, AND, OR, etc.).
2'b11: I-type instructions (ADDI, SLTI, etc.).
Funct7: A 7-bit function code from the instruction that helps to specify the exact ALU operation for R-type and I-type instructions.

Funct3: A 3-bit function code from the instruction that helps to specify the ALU operation.

ALUControl: A 4-bit control signal generated by this module to be sent to the ALU to perform the correct operation.

Operation Codes:

4'b0000: AND
4'b0001: OR
4'b0010: ADD
4'b0011: XOR
4'b0100: SLL (Shift Left Logical)
4'b0101: SRL (Shift Right Logical)
4'b0110: SUB
4'b0111: SRA (Shift Right Arithmetic)
4'b1000: SLT (Set Less Than)
4'b1001: SLTU (Set Less Than Unsigned)
This implementation ensures that the ALUControlUnit generates the appropriate ALU control signals based on the instruction being executed. 

*/

module ALUControlUnit (
    input [1:0] ALUOp,
    input [6:0] Funct7,
    input [2:0] Funct3,
    output reg [3:0] ALUControl
);

    always @(*) begin
        case (ALUOp)
            2'b00: begin // Load/Store instructions
                ALUControl = 4'b0010; // ADD operation
            end
            2'b01: begin // Branch instructions
                case (Funct3)
                    3'b000: ALUControl = 4'b0110; // BEQ (Subtract)
                    3'b001: ALUControl = 4'b0110; // BNE (Subtract)
                    3'b100: ALUControl = 4'b0111; // BLT (Set Less Than)
                    3'b101: ALUControl = 4'b0111; // BGE (Set Less Than)
                    3'b110: ALUControl = 4'b0111; // BLTU (Set Less Than Unsigned)
                    3'b111: ALUControl = 4'b0111; // BGEU (Set Less Than Unsigned)
                    default: ALUControl = 4'b0000; // Default case
                endcase
            end
            2'b10: begin // R-type instructions
                case ({Funct7, Funct3})
                    10'b0000000_000: ALUControl = 4'b0010; // ADD
                    10'b0100000_000: ALUControl = 4'b0110; // SUB
                    10'b0000000_111: ALUControl = 4'b0000; // AND
                    10'b0000000_110: ALUControl = 4'b0001; // OR
                    10'b0000000_100: ALUControl = 4'b0011; // XOR
                    10'b0000000_001: ALUControl = 4'b0100; // SLL (Shift Left Logical)
                    10'b0000000_101: ALUControl = 4'b0101; // SRL (Shift Right Logical)
                    10'b0100000_101: ALUControl = 4'b0111; // SRA (Shift Right Arithmetic)
                    10'b0000000_010: ALUControl = 4'b1000; // SLT (Set Less Than)
                    10'b0000000_011: ALUControl = 4'b1001; // SLTU (Set Less Than Unsigned)
                    default: ALUControl = 4'b0000; // Default case
                endcase
            end
            2'b11: begin // I-type instructions
                case (Funct3)
                    3'b000: ALUControl = 4'b0010; // ADDI
                    3'b010: ALUControl = 4'b1000; // SLTI (Set Less Than Immediate)
                    3'b011: ALUControl = 4'b1001; // SLTIU (Set Less Than Immediate Unsigned)
                    3'b100: ALUControl = 4'b0011; // XORI
                    3'b110: ALUControl = 4'b0001; // ORI
                    3'b111: ALUControl = 4'b0000; // ANDI
                    3'b001: ALUControl = 4'b0100; // SLLI (Shift Left Logical Immediate)
                    3'b101: begin
                        case (Funct7)
                            7'b0000000: ALUControl = 4'b0101; // SRLI (Shift Right Logical Immediate)
                            7'b0100000: ALUControl = 4'b0111; // SRAI (Shift Right Arithmetic Immediate)
                            default: ALUControl = 4'b0000; // Default case
                        endcase
                    end
                    default: ALUControl = 4'b0000; // Default case
                endcase
            end
            default: ALUControl = 4'b0000; // Default case
        endcase
    end

endmodule


/* 
Explanation:
Inputs:

A: The first operand for the ALU operation.
B: The second operand for the ALU operation.
ALUControl: A 4-bit control signal that specifies the operation to be performed.
Outputs:

Result: The result of the ALU operation.
Zero: A flag that is set to high (1) if the result of the operation is zero, otherwise it is set to low (0).
Operations:

4'b0010: ADD - Adds operand A and B.
4'b0110: SUB - Subtracts operand B from A.
4'b0000: AND - Performs a bitwise AND operation between A and B.
4'b0001: OR - Performs a bitwise OR operation between A and B.
4'b0011: XOR - Performs a bitwise XOR operation between A and B.
4'b0100: SLL - Shifts A left by the number of positions specified in the lower 5 bits of B.
4'b0101: SRL - Shifts A right logically by the number of positions specified in the lower 5 bits of B.
4'b0117: SRA - Shifts A right arithmetically by the number of positions specified in the lower 5 bits of B.
4'b1000: SLT - Sets the result to 1 if A is less than B (signed comparison), otherwise sets the result to 0.
4'b1001: SLTU - Sets the result to 1 if A is less than B (unsigned comparison), otherwise sets the result to 0.
default: Sets the result to 0 for any undefined ALUControl codes.
Zero Flag:

The Zero flag is set to high (1) if the Result is zero, indicating that the operation resulted in zero. This is useful for branch instructions that depend on comparison results.
This implementation ensures that the ALU module can perform a variety of arithmetic and logical operations as specified by the control signals. 

*/

module ALU (
    input [31:0] A,        // First operand
    input [31:0] B,        // Second operand
    input [3:0] ALUControl, // Control signal indicating the operation to perform
    output reg [31:0] Result, // Result of the operation
    output Zero            // Zero flag, indicates if the result is zero
);

    always @(*) begin
        case (ALUControl)
            4'b0010: Result = A + B;          // ADD
            4'b0110: Result = A - B;          // SUB
            4'b0000: Result = A & B;          // AND
            4'b0001: Result = A | B;          // OR
            4'b0011: Result = A ^ B;          // XOR
            4'b0100: Result = A << B[4:0];    // SLL (Shift Left Logical)
            4'b0101: Result = A >> B[4:0];    // SRL (Shift Right Logical)
            4'b0111: Result = A >>> B[4:0];   // SRA (Shift Right Arithmetic)
            4'b1000: Result = ($signed(A) < $signed(B)) ? 32'b1 : 32'b0; // SLT (Set Less Than)
            4'b1001: Result = (A < B) ? 32'b1 : 32'b0; // SLTU (Set Less Than Unsigned)
            default: Result = 32'b0;          // Default case
        endcase
    end

    // Zero flag is high if the result is zero
    assign Zero = (Result == 0) ? 1'b1 : 1'b0;

endmodule